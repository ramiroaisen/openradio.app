import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as stores$1, z as validate_store, A as component_subscribe, y as stores, ac as signalUrl, B as canonical, C as create_component, D as claim_component, E as mount_component, p as transition_in, v as transition_out, F as destroy_component, e as element, H as text, a as space, b as claim_element, h as children, I as claim_text, f as detach_dev, g as claim_space, k as add_location, m as insert_dev, l as append_dev, J as set_data_dev } from './client.34d0e543.js';
import { P as Page } from './Page.17ccbce0.js';
import { R as RadioList } from './RadioList.0e3babd3.js';

/* src/routes/_shared/signal.svelte generated by Svelte v3.18.2 */
const file = "src/routes/_shared/signal.svelte";

// (51:0) <Page {meta}>
function create_default_slot(ctx) {
	let h1;
	let t0;
	let t1;
	let current;

	const radiolist = new RadioList({
			props: {
				stations: /*stations*/ ctx[0],
				paging: /*paging*/ ctx[2],
				apiUrl: /*apiUrl*/ ctx[1],
				url: /*url*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text(/*title*/ ctx[4]);
			t1 = space();
			create_component(radiolist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[4]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(radiolist.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 51, 2, 1653);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(radiolist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*title*/ 16) set_data_dev(t0, /*title*/ ctx[4]);
			const radiolist_changes = {};
			if (dirty & /*stations*/ 1) radiolist_changes.stations = /*stations*/ ctx[0];
			if (dirty & /*paging*/ 4) radiolist_changes.paging = /*paging*/ ctx[2];
			if (dirty & /*apiUrl*/ 2) radiolist_changes.apiUrl = /*apiUrl*/ ctx[1];
			if (dirty & /*url*/ 8) radiolist_changes.url = /*url*/ ctx[3];
			radiolist.$set(radiolist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiolist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radiolist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(radiolist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(51:0) <Page {meta}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current;

	const page_1 = new Page({
			props: {
				meta: /*meta*/ ctx[5],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(page_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(page_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_1_changes = {};
			if (dirty & /*meta*/ 32) page_1_changes.meta = /*meta*/ ctx[5];

			if (dirty & /*$$scope, stations, paging, apiUrl, url, title*/ 65567) {
				page_1_changes.$$scope = { dirty, ctx };
			}

			page_1.$set(page_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload($page, $session) {
	let apiUrl = `/api/signal/${$page.params.signalType}/${$page.params.signalFrec}`;

	if ($page.params.langCountry) {
		const [$lang, $countryCode] = $page.params.langCountry.split("-");
		apiUrl += `?countryCode=${$countryCode}`;
	}

	const { items: stations, paging } = await this.fetch(apiUrl).then(res => res.json());
	return { stations, paging, apiUrl };
}

function instance($$self, $$props, $$invalidate) {
	let $page;
	let $lang;
	let $countryCode;
	let $trans;
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(11, $page = value));
	const { lang, trans, countryCode } = stores();
	validate_store(lang, "lang");
	component_subscribe($$self, lang, value => $$invalidate(13, $lang = value));
	validate_store(trans, "trans");
	component_subscribe($$self, trans, value => $$invalidate(15, $trans = value));
	validate_store(countryCode, "countryCode");
	component_subscribe($$self, countryCode, value => $$invalidate(14, $countryCode = value));
	let { stations } = $$props;
	let { apiUrl } = $$props;
	let { paging } = $$props;
	const writable_props = ["stations", "apiUrl", "paging"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Signal> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("stations" in $$props) $$invalidate(0, stations = $$props.stations);
		if ("apiUrl" in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
		if ("paging" in $$props) $$invalidate(2, paging = $$props.paging);
	};

	$$self.$capture_state = () => {
		return {
			stations,
			apiUrl,
			paging,
			type,
			$page,
			frec,
			url,
			$lang,
			$countryCode,
			title,
			$trans,
			meta
		};
	};

	$$self.$inject_state = $$props => {
		if ("stations" in $$props) $$invalidate(0, stations = $$props.stations);
		if ("apiUrl" in $$props) $$invalidate(1, apiUrl = $$props.apiUrl);
		if ("paging" in $$props) $$invalidate(2, paging = $$props.paging);
		if ("type" in $$props) $$invalidate(10, type = $$props.type);
		if ("$page" in $$props) page.set($page = $$props.$page);
		if ("frec" in $$props) $$invalidate(12, frec = $$props.frec);
		if ("url" in $$props) $$invalidate(3, url = $$props.url);
		if ("$lang" in $$props) lang.set($lang = $$props.$lang);
		if ("$countryCode" in $$props) countryCode.set($countryCode = $$props.$countryCode);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
		if ("$trans" in $$props) trans.set($trans = $$props.$trans);
		if ("meta" in $$props) $$invalidate(5, meta = $$props.meta);
	};

	let type;
	let frec;
	let url;
	let title;
	let meta;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$page*/ 2048) {
			 $$invalidate(10, type = $page.params.signalType);
		}

		if ($$self.$$.dirty & /*$page*/ 2048) {
			 $$invalidate(12, frec = $page.params.signalFrec);
		}

		if ($$self.$$.dirty & /*$lang, type, frec, $countryCode*/ 29696) {
			 $$invalidate(3, url = signalUrl({
				lang: $lang,
				type,
				frec,
				countryCode: $countryCode
			}));
		}

		if ($$self.$$.dirty & /*$countryCode, $trans, type, frec*/ 54272) {
			 $$invalidate(4, title = $countryCode
			? $trans("signal.country.title", {
					type,
					frec,
					country: $trans(`countries.${$countryCode}`)
				})
			: $trans("signal.global.title", { type, frec }));
		}

		if ($$self.$$.dirty & /*$countryCode, $trans, type, frec, url*/ 54280) {
			 $$invalidate(5, meta = $countryCode
			? {
					title: $trans("signal.head.country.title", {
						type,
						frec,
						country: $trans(`countries.${$countryCode}`)
					}),
					desc: $trans("signal.head.country.desc", {
						type,
						frec,
						country: $trans(`countries.${$countryCode}`)
					}),
					canonical: canonical(url)
				}
			: {
					title: $trans("signal.head.global.title", { type, frec }),
					desc: $trans("signal.head.global.title", { type, frec }),
					canonical: canonical(url)
				});
		}
	};

	return [stations, apiUrl, paging, url, title, meta, page, lang, trans, countryCode];
}

class Signal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { stations: 0, apiUrl: 1, paging: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Signal",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stations*/ ctx[0] === undefined && !("stations" in props)) {
			console.warn("<Signal> was created without expected prop 'stations'");
		}

		if (/*apiUrl*/ ctx[1] === undefined && !("apiUrl" in props)) {
			console.warn("<Signal> was created without expected prop 'apiUrl'");
		}

		if (/*paging*/ ctx[2] === undefined && !("paging" in props)) {
			console.warn("<Signal> was created without expected prop 'paging'");
		}
	}

	get stations() {
		throw new Error("<Signal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stations(value) {
		throw new Error("<Signal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get apiUrl() {
		throw new Error("<Signal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set apiUrl(value) {
		throw new Error("<Signal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get paging() {
		throw new Error("<Signal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set paging(value) {
		throw new Error("<Signal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Signal as C, preload as p };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmNjM2JjNzNjLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL19zaGFyZWQvc2lnbmFsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoJHBhZ2UsICRzZXNzaW9uKXtcbiAgICBsZXQgYXBpVXJsID0gYC9hcGkvc2lnbmFsLyR7JHBhZ2UucGFyYW1zLnNpZ25hbFR5cGV9LyR7JHBhZ2UucGFyYW1zLnNpZ25hbEZyZWN9YDtcbiAgICBpZigkcGFnZS5wYXJhbXMubGFuZ0NvdW50cnkpe1xuICAgICAgY29uc3QgWyRsYW5nLCAkY291bnRyeUNvZGVdID0gJHBhZ2UucGFyYW1zLmxhbmdDb3VudHJ5LnNwbGl0KFwiLVwiKTtcbiAgICAgIGFwaVVybCArPSBgP2NvdW50cnlDb2RlPSR7JGNvdW50cnlDb2RlfWA7XG4gICAgfVxuXG4gICAgY29uc3Qge2l0ZW1zOiBzdGF0aW9ucywgcGFnaW5nfSA9IGF3YWl0IHRoaXMuZmV0Y2goYXBpVXJsKS50aGVuKHJlcyA9PiByZXMuanNvbigpKTtcblxuICAgIHJldHVybiB7c3RhdGlvbnMsIHBhZ2luZywgYXBpVXJsfTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBQYWdlIGZyb20gXCIvQ29tcG9uZW50cy9QYWdlLnN2ZWx0ZVwiO1xuICBpbXBvcnQgUmFkaW9MaXN0IGZyb20gXCIvQ29tcG9uZW50cy9SYWRpb0xpc3Quc3ZlbHRlXCI7XG5cbiAgaW1wb3J0IHtzdG9yZXN9IGZyb20gXCJAc2FwcGVyL2FwcFwiO1xuICBjb25zdCB7cGFnZX0gPSBzdG9yZXMoKTtcblxuICBpbXBvcnQgKiBhcyBpMThuIGZyb20gXCIvQ29tbW9uL2kxOG5cIjtcbiAgY29uc3Qge2xhbmcsIHRyYW5zLCBjb3VudHJ5Q29kZX0gPSBpMThuLnN0b3JlcygpO1xuICBcbiAgaW1wb3J0IHtjYW5vbmljYWwsIHNpZ25hbFVybH0gZnJvbSBcIi9Db21tb24vdXJsc1wiO1xuXG4gIGV4cG9ydCBsZXQgc3RhdGlvbnM7XG4gIGV4cG9ydCBsZXQgYXBpVXJsO1xuICBleHBvcnQgbGV0IHBhZ2luZztcblxuICAkOiB0eXBlID0gJHBhZ2UucGFyYW1zLnNpZ25hbFR5cGU7XG4gICQ6IGZyZWMgPSAkcGFnZS5wYXJhbXMuc2lnbmFsRnJlYztcblxuICAkOiB1cmwgPSBzaWduYWxVcmwoe2xhbmc6ICRsYW5nLCB0eXBlLCBmcmVjLCBjb3VudHJ5Q29kZTogJGNvdW50cnlDb2RlfSk7XG5cbiAgJDogdGl0bGUgPSAkY291bnRyeUNvZGUgPyBcbiAgICAkdHJhbnMoXCJzaWduYWwuY291bnRyeS50aXRsZVwiLCB7dHlwZSwgZnJlYywgY291bnRyeTogJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCl9KSA6IFxuICAgICR0cmFucyhcInNpZ25hbC5nbG9iYWwudGl0bGVcIiwge3R5cGUsIGZyZWN9KTtcblxuICAkOiBtZXRhID0gJGNvdW50cnlDb2RlID8ge1xuICAgIHRpdGxlOiAkdHJhbnMoXCJzaWduYWwuaGVhZC5jb3VudHJ5LnRpdGxlXCIsIHt0eXBlLCBmcmVjLCBjb3VudHJ5OiAkdHJhbnMoYGNvdW50cmllcy4keyRjb3VudHJ5Q29kZX1gKX0pLFxuICAgIGRlc2M6ICR0cmFucyhcInNpZ25hbC5oZWFkLmNvdW50cnkuZGVzY1wiLCB7dHlwZSwgZnJlYywgY291bnRyeTogJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCl9KSxcbiAgICBjYW5vbmljYWw6IGNhbm9uaWNhbCh1cmwpXG4gIH0gOiB7XG4gICAgdGl0bGU6ICR0cmFucyhcInNpZ25hbC5oZWFkLmdsb2JhbC50aXRsZVwiLCB7dHlwZSwgZnJlY30pLFxuICAgIGRlc2M6ICR0cmFucyhcInNpZ25hbC5oZWFkLmdsb2JhbC50aXRsZVwiLCB7dHlwZSwgZnJlY30pLFxuICAgIGNhbm9uaWNhbDogY2Fub25pY2FsKHVybClcbiAgfTtcbjwvc2NyaXB0PlxuXG48UGFnZSB7bWV0YX0+XG4gIDxoMT57dGl0bGV9PC9oMT5cbiAgPFJhZGlvTGlzdCB7c3RhdGlvbnN9IHtwYWdpbmd9IHthcGlVcmx9IHt1cmx9IC8+XG48L1BhZ2U+Il0sIm5hbWVzIjpbInN0b3JlcyIsImkxOG4uc3RvcmVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBbURPLEdBQUs7Ozs7Ozs7O3VDQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7O29FQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWxEWSxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVE7S0FDdkMsTUFBTSxrQkFBa0IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVOztLQUMzRSxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVc7U0FDbEIsS0FBSyxFQUFFLFlBQVksSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRztFQUNoRSxNQUFNLG9CQUFvQixZQUFZOzs7U0FHakMsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLFdBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSTtVQUV2RSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU07Ozs7Ozs7O1NBTDNCLElBQUksS0FBSUEsUUFBTTs7O1NBR2QsSUFBSSxFQUFFLEtBQUssRUFBRSxXQUFXLEtBQUlDLE1BQVc7Ozs7Ozs7T0FJbkMsUUFBUTtPQUNSLE1BQU07T0FDTixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFFZCxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVOzs7O3FCQUM5QixJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVOzs7O29CQUU5QixHQUFHLEdBQUcsU0FBUztJQUFFLElBQUksRUFBRSxLQUFLO0lBQUUsSUFBSTtJQUFFLElBQUk7SUFBRSxXQUFXLEVBQUUsWUFBWTs7Ozs7b0JBRW5FLEtBQUssR0FBRyxZQUFZO0tBQ3JCLE1BQU0sQ0FBQyxzQkFBc0I7S0FBRyxJQUFJO0tBQUUsSUFBSTtLQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsWUFBWTs7S0FDckYsTUFBTSxDQUFDLHFCQUFxQixJQUFHLElBQUksRUFBRSxJQUFJOzs7O29CQUV4QyxJQUFJLEdBQUcsWUFBWTs7S0FDcEIsS0FBSyxFQUFFLE1BQU0sQ0FBQywyQkFBMkI7TUFBRyxJQUFJO01BQUUsSUFBSTtNQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsWUFBWTs7S0FDakcsSUFBSSxFQUFFLE1BQU0sQ0FBQywwQkFBMEI7TUFBRyxJQUFJO01BQUUsSUFBSTtNQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsWUFBWTs7S0FDL0YsU0FBUyxFQUFFLFNBQVMsQ0FBQyxHQUFHOzs7S0FFeEIsS0FBSyxFQUFFLE1BQU0sQ0FBQywwQkFBMEIsSUFBRyxJQUFJLEVBQUUsSUFBSTtLQUNyRCxJQUFJLEVBQUUsTUFBTSxDQUFDLDBCQUEwQixJQUFHLElBQUksRUFBRSxJQUFJO0tBQ3BELFNBQVMsRUFBRSxTQUFTLENBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
