import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, x as stores$1, y as stores, z as validate_store, A as component_subscribe, B as canonical, C as create_component, D as claim_component, E as mount_component, p as transition_in, v as transition_out, F as destroy_component, G as indexUrl, e as element, H as text, a as space, b as claim_element, h as children, I as claim_text, f as detach_dev, g as claim_space, j as attr_dev, k as add_location, m as insert_dev, l as append_dev, J as set_data_dev, K as group_outros, L as check_outros, M as destroy_each, N as CountryFlag, O as countryUrl } from './client.f2270627.js';
import { P as Page } from './Page.3126f6f1.js';

/* src/routes/[lang([a-z]{2})]/index.svelte generated by Svelte v3.18.2 */
const file = "src/routes/[lang([a-z]{2})]/index.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (96:10) {#each cont.countries as country}
function create_each_block_1(ctx) {
	let li;
	let a;
	let t0;
	let t1_value = /*country*/ ctx[12].name + "";
	let t1;
	let a_href_value;
	let t2;
	let current;

	const countryflag = new CountryFlag({
			props: {
				size,
				style,
				countryCode: /*country*/ ctx[12].code
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			create_component(countryflag.$$.fragment);
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			claim_component(countryflag.$$.fragment, a_nodes);
			t0 = claim_space(a_nodes);
			t1 = claim_text(a_nodes, t1_value);
			a_nodes.forEach(detach_dev);
			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "class", "no-a underline-link svelte-13dqpv4");

			attr_dev(a, "href", a_href_value = countryUrl({
				lang: /*$lang*/ ctx[2],
				countryCode: /*country*/ ctx[12].code
			}));

			add_location(a, file, 97, 14, 2282);
			attr_dev(li, "class", "country svelte-13dqpv4");
			add_location(li, file, 96, 12, 2247);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			mount_component(countryflag, a, null);
			append_dev(a, t0);
			append_dev(a, t1);
			append_dev(li, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			const countryflag_changes = {};
			if (dirty & /*conts*/ 1) countryflag_changes.countryCode = /*country*/ ctx[12].code;
			countryflag.$set(countryflag_changes);
			if ((!current || dirty & /*conts*/ 1) && t1_value !== (t1_value = /*country*/ ctx[12].name + "")) set_data_dev(t1, t1_value);

			if (!current || dirty & /*$lang, conts*/ 5 && a_href_value !== (a_href_value = countryUrl({
				lang: /*$lang*/ ctx[2],
				countryCode: /*country*/ ctx[12].code
			}))) {
				attr_dev(a, "href", a_href_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(countryflag.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(countryflag.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(countryflag);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(96:10) {#each cont.countries as country}",
		ctx
	});

	return block;
}

// (92:4) {#each conts as cont}
function create_each_block(ctx) {
	let li;
	let div;
	let t0_value = /*cont*/ ctx[9].name + "";
	let t0;
	let t1;
	let ul;
	let t2;
	let current;
	let each_value_1 = /*cont*/ ctx[9].countries;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			li = element("li");
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			div = claim_element(li_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			ul = claim_element(li_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "contname svelte-13dqpv4");
			add_location(div, file, 93, 8, 2118);
			attr_dev(ul, "class", "countrylist svelte-13dqpv4");
			add_location(ul, file, 94, 8, 2166);
			attr_dev(li, "class", "contbox svelte-13dqpv4");
			add_location(li, file, 92, 6, 2089);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, div);
			append_dev(div, t0);
			append_dev(li, t1);
			append_dev(li, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(li, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*conts*/ 1) && t0_value !== (t0_value = /*cont*/ ctx[9].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*countryUrl, $lang, conts, size, style*/ 5) {
				each_value_1 = /*cont*/ ctx[9].countries;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(92:4) {#each conts as cont}",
		ctx
	});

	return block;
}

// (90:0) <Page {meta}>
function create_default_slot(ctx) {
	let ul;
	let current;
	let each_value = /*conts*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "contlist svelte-13dqpv4");
			add_location(ul, file, 90, 2, 2035);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*conts, countryUrl, $lang, size, style*/ 5) {
				each_value = /*conts*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(90:0) <Page {meta}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current;

	const page_1 = new Page({
			props: {
				meta: /*meta*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(page_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(page_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_1_changes = {};
			if (dirty & /*meta*/ 2) page_1_changes.meta = /*meta*/ ctx[1];

			if (dirty & /*$$scope, conts, $lang*/ 32773) {
				page_1_changes.$$scope = { dirty, ctx };
			}

			page_1.$set(page_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload($page, $session) {
	const continents = await this.fetch("/api/continents").then(res => res.json());
	return { continents };
}

const size = 24; // 16 24 32 48 64
const style = "shiny"; // flat shiny

function instance($$self, $$props, $$invalidate) {
	let $trans;
	let $lang;
	const { page } = stores$1();
	const { lang, trans } = stores();
	validate_store(lang, "lang");
	component_subscribe($$self, lang, value => $$invalidate(2, $lang = value));
	validate_store(trans, "trans");
	component_subscribe($$self, trans, value => $$invalidate(6, $trans = value));
	let { continents } = $$props;
	const sort = (a, b) => a.name.localeCompare(b.name);
	const writable_props = ["continents"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Blang_u5Ba_zu5Du7B2u7D_u5D> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("continents" in $$props) $$invalidate(5, continents = $$props.continents);
	};

	$$self.$capture_state = () => {
		return { continents, conts, $trans, meta, $lang };
	};

	$$self.$inject_state = $$props => {
		if ("continents" in $$props) $$invalidate(5, continents = $$props.continents);
		if ("conts" in $$props) $$invalidate(0, conts = $$props.conts);
		if ("$trans" in $$props) trans.set($trans = $$props.$trans);
		if ("meta" in $$props) $$invalidate(1, meta = $$props.meta);
		if ("$lang" in $$props) lang.set($lang = $$props.$lang);
	};

	let conts;
	let meta;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*continents, $trans*/ 96) {
			 $$invalidate(0, conts = continents.map(cont => {
				return {
					...cont,
					name: $trans(`continents.${cont.code}`),
					countries: cont.countries.map(country => {
						return {
							...country,
							name: $trans(`countries.${country.code}`)
						};
					}).sort(sort)
				};
			}).sort(sort));
		}

		if ($$self.$$.dirty & /*$trans, $lang*/ 68) {
			 $$invalidate(1, meta = {
				title: $trans("globalIndex.head.title"),
				desc: $trans("globalIndex.head.desc"),
				canonical: canonical(indexUrl({ lang: $lang }))
			});
		}
	};

	return [conts, meta, $lang, lang, trans, continents];
}

class U5Blang_u5Ba_zu5Du7B2u7D_u5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { continents: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Blang_u5Ba_zu5Du7B2u7D_u5D",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*continents*/ ctx[5] === undefined && !("continents" in props)) {
			console.warn("<U5Blang_u5Ba_zu5Du7B2u7D_u5D> was created without expected prop 'continents'");
		}
	}

	get continents() {
		throw new Error("<U5Blang_u5Ba_zu5Du7B2u7D_u5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set continents(value) {
		throw new Error("<U5Blang_u5Ba_zu5Du7B2u7D_u5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Blang_u5Ba_zu5Du7B2u7D_u5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMWJlYjcyYWYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvW2xhbmcoW2Etel17Mn0pXS9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKCRwYWdlLCAkc2Vzc2lvbil7XG4gICAgY29uc3QgY29udGluZW50cyA9IGF3YWl0IHRoaXMuZmV0Y2goXCIvYXBpL2NvbnRpbmVudHNcIikudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG4gICAgcmV0dXJuIHtjb250aW5lbnRzfTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLmNvbnRsaXN0IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgcGFkZGluZzogMS41ZW0gMTAlO1xuICAgIGJhY2tncm91bmQ6ICNmNWY1ZjU7XG4gIH1cblxuICAuY29udGJveCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1hcmdpbjogMS41ZW0gMDtcbiAgICBwYWRkaW5nOiAxLjVlbTtcbiAgICBib3gtc2hhZG93OiAwIDFweCAxcHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgMCAycHggMXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCAxcHggM3B4IDAgcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgIGJvcmRlci10b3A6IHZhcigtLXByaW1hcnktY29sb3IpIDZweCBzb2xpZDtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgfVxuXG4gIC5jb250bmFtZSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMWVtO1xuICB9XG5cbiAgLmNvdW50cnlsaXN0IHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZmlsbCwgbWlubWF4KDE1ZW0sIDFmcikpO1xuICAgIGdyaWQtY29sdW1uLWdhcDogMWVtO1xuICB9XG5cbiAgLmNvdW50cnkgPiBhIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDAuNWVtO1xuICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcbiAgfVxuXG4gIC5jb3VudHJ5IDpnbG9iYWwocGljdHVyZSl7XG4gICAgbWFyZ2luOiAwIDAuNWVtIDAgMDtcbiAgICB3aWR0aDogMjRweDtcbiAgICBoZWlnaHQ6IDI0cHg7XG4gIH1cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBQYWdlIGZyb20gXCIvQ29tcG9uZW50cy9QYWdlLnN2ZWx0ZVwiO1xuICBpbXBvcnQgQ291bnRyeUZsYWcgZnJvbSBcIi9Db21wb25lbnRzL0NvdW50cnlGbGFnLnN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBjYW5vbmljYWwsIGNvdW50cnlVcmwsIGluZGV4VXJsIH0gZnJvbSBcIi9Db21tb24vdXJsc1wiO1xuXG4gIGltcG9ydCB7IHN0b3JlcyB9IGZyb20gXCJAc2FwcGVyL2FwcFwiO1xuICBjb25zdCB7IHBhZ2UgfSA9IHN0b3JlcygpO1xuXG4gIGltcG9ydCAqIGFzIGkxOG4gZnJvbSBcIi9Db21tb24vaTE4blwiO1xuICBjb25zdCB7IGxhbmcsIHRyYW5zIH0gPSBpMThuLnN0b3JlcygpO1xuXG4gIGV4cG9ydCBsZXQgY29udGluZW50cztcblxuICBjb25zdCBzb3J0ID0gKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG5cbiAgJDogY29udHMgPSBjb250aW5lbnRzLm1hcChjb250ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udCwgXG4gICAgICBuYW1lOiAkdHJhbnMoYGNvbnRpbmVudHMuJHtjb250LmNvZGV9YCksXG4gICAgICBjb3VudHJpZXM6IGNvbnQuY291bnRyaWVzLm1hcChjb3VudHJ5ID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb3VudHJ5LFxuICAgICAgICAgIG5hbWU6ICR0cmFucyhgY291bnRyaWVzLiR7Y291bnRyeS5jb2RlfWApXG4gICAgICAgIH1cbiAgICAgIH0pLnNvcnQoc29ydClcbiAgICB9XG4gIH0pLnNvcnQoc29ydCk7XG5cbiAgY29uc3Qgc2l6ZSA9IDI0OyAvLyAxNiAyNCAzMiA0OCA2NFxuICBjb25zdCBzdHlsZSA9IFwic2hpbnlcIjsgLy8gZmxhdCBzaGlueVxuXG4gICQ6IG1ldGEgPSB7XG4gICAgdGl0bGU6ICR0cmFucyhcImdsb2JhbEluZGV4LmhlYWQudGl0bGVcIiksXG4gICAgZGVzYzogJHRyYW5zKFwiZ2xvYmFsSW5kZXguaGVhZC5kZXNjXCIpLFxuICAgIGNhbm9uaWNhbDogY2Fub25pY2FsKGluZGV4VXJsKHtsYW5nOiAkbGFuZ30pKVxuICB9O1xuPC9zY3JpcHQ+XG5cbjxQYWdlIHttZXRhfT5cbiAgPHVsIGNsYXNzPVwiY29udGxpc3RcIj5cbiAgICB7I2VhY2ggY29udHMgYXMgY29udH1cbiAgICAgIDxsaSBjbGFzcz1cImNvbnRib3hcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRuYW1lXCI+e2NvbnQubmFtZX08L2Rpdj5cbiAgICAgICAgPHVsIGNsYXNzPVwiY291bnRyeWxpc3RcIj5cbiAgICAgICAgICB7I2VhY2ggY29udC5jb3VudHJpZXMgYXMgY291bnRyeX1cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImNvdW50cnlcIj5cbiAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuby1hIHVuZGVybGluZS1saW5rXCIgaHJlZj17Y291bnRyeVVybCh7IGxhbmc6ICRsYW5nLCBjb3VudHJ5Q29kZTogY291bnRyeS5jb2RlIH0pfT5cbiAgICAgICAgICAgICAgICA8Q291bnRyeUZsYWcge3NpemV9IHtzdHlsZX0gY291bnRyeUNvZGU9e2NvdW50cnkuY29kZX0gLz5cbiAgICAgICAgICAgICAgICB7Y291bnRyeS5uYW1lfVxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvbGk+XG4gICAgey9lYWNofVxuICA8L3VsPlxuPC9QYWdlPlxuIl0sIm5hbWVzIjpbInN0b3JlcyIsImkxOG4uc3RvcmVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFtR2lCLEdBQU8sS0FBQyxJQUFJOzs7Ozs7Ozs7OzZCQUQ0QixHQUFPLEtBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FEbEIsVUFBVTtJQUFHLElBQUksWUFBRSxHQUFLO0lBQUUsV0FBVyxjQUFFLEdBQU8sS0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEVBQzdDLEdBQU8sS0FBQyxJQUFJOztpRkFDcEQsR0FBTyxLQUFDLElBQUk7O2tGQUZzQixVQUFVO0lBQUcsSUFBSSxZQUFFLEdBQUs7SUFBRSxXQUFXLGNBQUUsR0FBTyxLQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQUp2RSxHQUFJLElBQUMsSUFBSTs7Ozs7OzZCQUV2QixHQUFJLElBQUMsU0FBUzs7O2tDQUFuQixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEVBRmUsR0FBSSxJQUFDLElBQUk7Ozs0QkFFdkIsR0FBSSxJQUFDLFNBQVM7OztpQ0FBbkIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OzswQkFBSixNQUFJOzs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFKTCxHQUFLOzs7Z0NBQVYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBQUMsR0FBSzs7OytCQUFWLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBQUosTUFBSTs7Ozs7Ozs7OztrQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUExRmMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRO09BQ3JDLFVBQVUsU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUk7VUFDbkUsVUFBVTs7O01BeUJkLElBQUksR0FBRyxFQUFFO01BQ1QsS0FBSyxHQUFHLE9BQU87Ozs7O1NBdkJiLElBQUksS0FBS0EsUUFBTTtTQUdmLElBQUksRUFBRSxLQUFLLEtBQUtDLE1BQVc7Ozs7O09BRXhCLFVBQVU7T0FFZixJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFFL0MsS0FBSyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSTs7UUFFdkIsSUFBSTtLQUNQLElBQUksRUFBRSxNQUFNLGVBQWUsSUFBSSxDQUFDLElBQUk7S0FDcEMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU87O1VBRTlCLE9BQU87T0FDVixJQUFJLEVBQUUsTUFBTSxjQUFjLE9BQU8sQ0FBQyxJQUFJOztRQUV2QyxJQUFJLENBQUMsSUFBSTs7TUFFYixJQUFJLENBQUMsSUFBSTs7OztvQkFLVCxJQUFJO0lBQ0wsS0FBSyxFQUFFLE1BQU0sQ0FBQyx3QkFBd0I7SUFDdEMsSUFBSSxFQUFFLE1BQU0sQ0FBQyx1QkFBdUI7SUFDcEMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEdBQUUsSUFBSSxFQUFFLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
