import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as stores$1, z as validate_store, A as component_subscribe, y as stores, ah as searchUrl, B as canonical, C as create_component, D as claim_component, E as mount_component, p as transition_in, v as transition_out, F as destroy_component, e as element, H as text, a as space, b as claim_element, h as children, I as claim_text, f as detach_dev, g as claim_space, j as attr_dev, k as add_location, m as insert_dev, l as append_dev, J as set_data_dev } from './client.09190980.js';
import { P as Page } from './Page.a348143e.js';
import { R as RadioList } from './RadioList.465b2288.js';

/* src/routes/_shared/search.svelte generated by Svelte v3.18.2 */
const file = "src/routes/_shared/search.svelte";

// (65:0) <Page {meta}>
function create_default_slot(ctx) {
	let h1;
	let t0;
	let t1;
	let div;

	let t2_value = /*$trans*/ ctx[6]("search.timing", {
		total: /*paging*/ ctx[1].total,
		s: (/*time*/ ctx[2] / 1000).toFixed(2)
	}) + "";

	let t2;
	let t3;
	let current;

	const radiolist = new RadioList({
			props: {
				stations: /*stations*/ ctx[0],
				paging: /*paging*/ ctx[1],
				url: /*url*/ ctx[5],
				apiUrl: /*apiUrl*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text(/*q*/ ctx[4]);
			t1 = space();
			div = element("div");
			t2 = text(t2_value);
			t3 = space();
			create_component(radiolist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*q*/ ctx[4]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t2 = claim_text(div_nodes, t2_value);
			div_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			claim_component(radiolist.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-p013sm");
			add_location(h1, file, 65, 2, 1846);
			attr_dev(div, "class", "timing svelte-p013sm");
			add_location(div, file, 66, 2, 1861);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, t2);
			insert_dev(target, t3, anchor);
			mount_component(radiolist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*q*/ 16) set_data_dev(t0, /*q*/ ctx[4]);

			if ((!current || dirty & /*$trans, paging, time*/ 70) && t2_value !== (t2_value = /*$trans*/ ctx[6]("search.timing", {
				total: /*paging*/ ctx[1].total,
				s: (/*time*/ ctx[2] / 1000).toFixed(2)
			}) + "")) set_data_dev(t2, t2_value);

			const radiolist_changes = {};
			if (dirty & /*stations*/ 1) radiolist_changes.stations = /*stations*/ ctx[0];
			if (dirty & /*paging*/ 2) radiolist_changes.paging = /*paging*/ ctx[1];
			if (dirty & /*url*/ 32) radiolist_changes.url = /*url*/ ctx[5];
			if (dirty & /*apiUrl*/ 8) radiolist_changes.apiUrl = /*apiUrl*/ ctx[3];
			radiolist.$set(radiolist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiolist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radiolist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t3);
			destroy_component(radiolist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(65:0) <Page {meta}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current;

	const page_1 = new Page({
			props: {
				meta: /*meta*/ ctx[7],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(page_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(page_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_1_changes = {};
			if (dirty & /*meta*/ 128) page_1_changes.meta = /*meta*/ ctx[7];

			if (dirty & /*$$scope, stations, paging, url, apiUrl, $trans, time, q*/ 65663) {
				page_1_changes.$$scope = { dirty, ctx };
			}

			page_1.$set(page_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload($page, $session) {
	const page = $page.query.page | 0 || 1;
	let apiUrl = `/api/search?q=${encodeURIComponent($page.query.q || "")}`;

	// is country-wise
	if ($page.params.langCountry) {
		const [$lang, $countryCode] = $page.params.langCountry.split("-");
		apiUrl += `&countryCode=${$countryCode}`;
	}

	const { items: stations, paging, time } = await this.fetch(`${apiUrl}&page=${page}`).then(res => res.json());
	return { stations, paging, apiUrl, time };
}

function instance($$self, $$props, $$invalidate) {
	let $page;
	let $lang;
	let $countryCode;
	let $trans;
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(12, $page = value));
	const { trans, lang, countryCode } = stores();
	validate_store(trans, "trans");
	component_subscribe($$self, trans, value => $$invalidate(6, $trans = value));
	validate_store(lang, "lang");
	component_subscribe($$self, lang, value => $$invalidate(13, $lang = value));
	validate_store(countryCode, "countryCode");
	component_subscribe($$self, countryCode, value => $$invalidate(14, $countryCode = value));
	let { stations } = $$props;
	let { paging } = $$props;
	let { time } = $$props;
	let { apiUrl } = $$props;
	const writable_props = ["stations", "paging", "time", "apiUrl"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Search> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("stations" in $$props) $$invalidate(0, stations = $$props.stations);
		if ("paging" in $$props) $$invalidate(1, paging = $$props.paging);
		if ("time" in $$props) $$invalidate(2, time = $$props.time);
		if ("apiUrl" in $$props) $$invalidate(3, apiUrl = $$props.apiUrl);
	};

	$$self.$capture_state = () => {
		return {
			stations,
			paging,
			time,
			apiUrl,
			q,
			$page,
			url,
			$lang,
			$countryCode,
			countryName,
			$trans,
			meta
		};
	};

	$$self.$inject_state = $$props => {
		if ("stations" in $$props) $$invalidate(0, stations = $$props.stations);
		if ("paging" in $$props) $$invalidate(1, paging = $$props.paging);
		if ("time" in $$props) $$invalidate(2, time = $$props.time);
		if ("apiUrl" in $$props) $$invalidate(3, apiUrl = $$props.apiUrl);
		if ("q" in $$props) $$invalidate(4, q = $$props.q);
		if ("$page" in $$props) page.set($page = $$props.$page);
		if ("url" in $$props) $$invalidate(5, url = $$props.url);
		if ("$lang" in $$props) lang.set($lang = $$props.$lang);
		if ("$countryCode" in $$props) countryCode.set($countryCode = $$props.$countryCode);
		if ("countryName" in $$props) countryName = $$props.countryName;
		if ("$trans" in $$props) trans.set($trans = $$props.$trans);
		if ("meta" in $$props) $$invalidate(7, meta = $$props.meta);
	};

	let q;
	let url;
	let countryName;
	let meta;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$page*/ 4096) {
			 $$invalidate(4, q = $page.query.q || "");
		}

		if ($$self.$$.dirty & /*$lang, $countryCode, q*/ 24592) {
			 $$invalidate(5, url = searchUrl({
				lang: $lang,
				countryCode: $countryCode,
				q
			}));
		}

		if ($$self.$$.dirty & /*$countryCode, $trans*/ 16448) {
			//$: subtitleKey = $countryCode ? "search.country.subtitle" : "search.global.subtitle";
			 countryName = $countryCode && $trans(`countries.${$countryCode}`);
		}

		if ($$self.$$.dirty & /*$countryCode, $trans, q, url*/ 16496) {
			 $$invalidate(7, meta = $countryCode
			? {
					title: $trans("search.head.country.title", {
						q,
						country: $trans(`countries.${$countryCode}`)
					}),
					desc: $trans("search.head.country.desc", {
						q,
						country: $trans(`countries.${$countryCode}`)
					}),
					canonical: canonical(url)
				}
			: {
					title: $trans("signal.head.global.title", { q }),
					desc: $trans("signal.head.global.title", { q }),
					canonical: canonical(url)
				});
		}
	};

	return [
		stations,
		paging,
		time,
		apiUrl,
		q,
		url,
		$trans,
		meta,
		page,
		trans,
		lang,
		countryCode
	];
}

class Search extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			stations: 0,
			paging: 1,
			time: 2,
			apiUrl: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Search",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stations*/ ctx[0] === undefined && !("stations" in props)) {
			console.warn("<Search> was created without expected prop 'stations'");
		}

		if (/*paging*/ ctx[1] === undefined && !("paging" in props)) {
			console.warn("<Search> was created without expected prop 'paging'");
		}

		if (/*time*/ ctx[2] === undefined && !("time" in props)) {
			console.warn("<Search> was created without expected prop 'time'");
		}

		if (/*apiUrl*/ ctx[3] === undefined && !("apiUrl" in props)) {
			console.warn("<Search> was created without expected prop 'apiUrl'");
		}
	}

	get stations() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stations(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get paging() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set paging(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get time() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set time(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get apiUrl() {
		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set apiUrl(value) {
		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Search as S, preload as p };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLmVjMWUwMmYxLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL19zaGFyZWQvc2VhcmNoLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGU+XG4gIGgxe1xuICAgIG1hcmdpbi1ib3R0b206IDAgIWltcG9ydGFudDtcbiAgfVxuXG4gIC50aW1pbmd7XG4gICAgZm9udC1zaXplOiAxZW07XG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICBtYXJnaW4tdG9wOiAwLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAyZW07XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG48L3N0eWxlPlxuXG48c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoJHBhZ2UsICRzZXNzaW9uKXtcbiAgICBjb25zdCBwYWdlID0gKCRwYWdlLnF1ZXJ5LnBhZ2UgfCAwKSB8fCAxO1xuICAgIGxldCBhcGlVcmwgPSBgL2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudCgkcGFnZS5xdWVyeS5xIHx8IFwiXCIpfWA7XG4gICAgLy8gaXMgY291bnRyeS13aXNlXG4gICAgaWYoJHBhZ2UucGFyYW1zLmxhbmdDb3VudHJ5KXtcbiAgICAgIGNvbnN0IFskbGFuZywgJGNvdW50cnlDb2RlXSA9ICRwYWdlLnBhcmFtcy5sYW5nQ291bnRyeS5zcGxpdChcIi1cIik7XG4gICAgICBhcGlVcmwgKz0gYCZjb3VudHJ5Q29kZT0keyRjb3VudHJ5Q29kZX1gO1xuICAgIH1cblxuICAgIGNvbnN0IHtpdGVtczogc3RhdGlvbnMsIHBhZ2luZywgdGltZX0gPSBhd2FpdCB0aGlzLmZldGNoKGAke2FwaVVybH0mcGFnZT0ke3BhZ2V9YCkudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG4gICAgcmV0dXJuIHtzdGF0aW9ucywgcGFnaW5nLCBhcGlVcmwsIHRpbWV9O1xuICB9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IFBhZ2UgZnJvbSBcIi9Db21wb25lbnRzL1BhZ2Uuc3ZlbHRlXCI7XG4gIGltcG9ydCBSYWRpb0xpc3QgZnJvbSBcIi9Db21wb25lbnRzL1JhZGlvTGlzdC5zdmVsdGVcIjtcblxuICBpbXBvcnQge2Nhbm9uaWNhbCwgc2VhcmNoVXJsfSBmcm9tIFwiL0NvbW1vbi91cmxzXCI7XG5cbiAgaW1wb3J0IHtzdG9yZXN9IGZyb20gXCJAc2FwcGVyL2FwcFwiO1xuICBjb25zdCB7cGFnZX0gPSBzdG9yZXMoKTtcblxuICBpbXBvcnQgKiBhcyBpMThuIGZyb20gXCIvQ29tbW9uL2kxOG5cIjtcbiAgY29uc3Qge3RyYW5zLCBsYW5nLCBjb3VudHJ5Q29kZX0gPSBpMThuLnN0b3JlcygpO1xuXG4gIGV4cG9ydCBsZXQgc3RhdGlvbnM7XG4gIGV4cG9ydCBsZXQgcGFnaW5nO1xuICBleHBvcnQgbGV0IHRpbWU7XG4gIGV4cG9ydCBsZXQgYXBpVXJsO1xuXG4gICQ6IHEgPSAkcGFnZS5xdWVyeS5xIHx8IFwiXCI7XG5cbiAgJDogdXJsID0gc2VhcmNoVXJsKHtsYW5nOiAkbGFuZywgY291bnRyeUNvZGU6ICRjb3VudHJ5Q29kZSwgcX0pO1xuXG4gIC8vJDogc3VidGl0bGVLZXkgPSAkY291bnRyeUNvZGUgPyBcInNlYXJjaC5jb3VudHJ5LnN1YnRpdGxlXCIgOiBcInNlYXJjaC5nbG9iYWwuc3VidGl0bGVcIjtcbiAgJDogY291bnRyeU5hbWUgPSAkY291bnRyeUNvZGUgJiYgJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCk7XG5cbiAgJDogbWV0YSA9ICRjb3VudHJ5Q29kZSA/IHtcbiAgICB0aXRsZTogJHRyYW5zKFwic2VhcmNoLmhlYWQuY291bnRyeS50aXRsZVwiLCB7cSwgY291bnRyeTogJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCl9KSxcbiAgICBkZXNjOiAkdHJhbnMoXCJzZWFyY2guaGVhZC5jb3VudHJ5LmRlc2NcIiwge3EsIGNvdW50cnk6ICR0cmFucyhgY291bnRyaWVzLiR7JGNvdW50cnlDb2RlfWApfSksXG4gICAgY2Fub25pY2FsOiBjYW5vbmljYWwodXJsKVxuICB9IDoge1xuICAgIHRpdGxlOiAkdHJhbnMoXCJzaWduYWwuaGVhZC5nbG9iYWwudGl0bGVcIiwge3F9KSxcbiAgICBkZXNjOiAkdHJhbnMoXCJzaWduYWwuaGVhZC5nbG9iYWwudGl0bGVcIiwge3F9KSxcbiAgICBjYW5vbmljYWw6IGNhbm9uaWNhbCh1cmwpXG4gIH07XG48L3NjcmlwdD5cblxuPFBhZ2Uge21ldGF9PlxuICA8aDE+e3F9PC9oMT5cbiAgPGRpdiBjbGFzcz1cInRpbWluZ1wiPnskdHJhbnMoXCJzZWFyY2gudGltaW5nXCIsIHt0b3RhbDogcGFnaW5nLnRvdGFsLCBzOiAodGltZS8xMDAwKS50b0ZpeGVkKDIpfSl9PC9kaXY+XG4gIDxSYWRpb0xpc3Qge3N0YXRpb25zfSB7cGFnaW5nfSB7dXJsfSB7YXBpVXJsfSAvPlxuPC9QYWdlPlxuXG4iXSwibmFtZXMiOlsic3RvcmVzIiwiaTE4bi5zdG9yZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OzJCQWtFdUIsR0FBTSxJQUFDLGVBQWU7RUFBRyxLQUFLLGFBQUUsR0FBTSxJQUFDLEtBQUs7RUFBRSxDQUFDLFlBQUcsR0FBSSxNQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBRHRGLEdBQUM7Ozs7Ozs7Ozs7O21DQUFELEdBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NERBQUQsR0FBQzs7Z0dBQ2UsR0FBTSxJQUFDLGVBQWU7SUFBRyxLQUFLLGFBQUUsR0FBTSxJQUFDLEtBQUs7SUFBRSxDQUFDLFlBQUcsR0FBSSxNQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWpFckUsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRO09BQ3JDLElBQUksR0FBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUssQ0FBQztLQUNwQyxNQUFNLG9CQUFvQixrQkFBa0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFOzs7S0FFakUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXO1NBQ2xCLEtBQUssRUFBRSxZQUFZLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUc7RUFDaEUsTUFBTSxvQkFBb0IsWUFBWTs7O1NBR2pDLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLElBQUksV0FBVSxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sU0FBUyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSTtVQUMvRixRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJOzs7Ozs7OztTQUpqQyxJQUFJLEtBQUlBLFFBQU07OztTQUdkLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVyxLQUFJQyxNQUFXOzs7Ozs7O09BRW5DLFFBQVE7T0FDUixNQUFNO09BQ04sSUFBSTtPQUNKLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUVkLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFOzs7O29CQUV2QixHQUFHLEdBQUcsU0FBUztJQUFFLElBQUksRUFBRSxLQUFLO0lBQUUsV0FBVyxFQUFFLFlBQVk7SUFBRSxDQUFDOzs7Ozs7SUFHMUQsV0FBVyxHQUFHLFlBQVksSUFBSSxNQUFNLGNBQWMsWUFBWTs7OztvQkFFOUQsSUFBSSxHQUFHLFlBQVk7O0tBQ3BCLEtBQUssRUFBRSxNQUFNLENBQUMsMkJBQTJCO01BQUcsQ0FBQztNQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsWUFBWTs7S0FDeEYsSUFBSSxFQUFFLE1BQU0sQ0FBQywwQkFBMEI7TUFBRyxDQUFDO01BQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxZQUFZOztLQUN0RixTQUFTLEVBQUUsU0FBUyxDQUFDLEdBQUc7OztLQUV4QixLQUFLLEVBQUUsTUFBTSxDQUFDLDBCQUEwQixJQUFHLENBQUM7S0FDNUMsSUFBSSxFQUFFLE1BQU0sQ0FBQywwQkFBMEIsSUFBRyxDQUFDO0tBQzNDLFNBQVMsRUFBRSxTQUFTLENBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
