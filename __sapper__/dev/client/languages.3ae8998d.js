import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, x as stores$1, y as stores, z as validate_store, A as component_subscribe, Q as map, B as canonical, R as langsUrl, C as create_component, D as claim_component, E as mount_component, p as transition_in, v as transition_out, F as destroy_component, e as element, H as text, a as space, b as claim_element, h as children, I as claim_text, f as detach_dev, g as claim_space, k as add_location, m as insert_dev, l as append_dev, J as set_data_dev, G as indexUrl, P as noop, T as empty, K as group_outros, L as check_outros, M as destroy_each } from './client.f2270627.js';
import { P as Page } from './Page.3126f6f1.js';
import { L as LinkListBox, U as UnderlineLink } from './LinkListBox.2b1359f9.js';

/* src/routes/[lang([a-z]{2})]/languages.svelte generated by Svelte v3.18.2 */
const file = "src/routes/[lang([a-z]{2})]/languages.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (31:4) {#each langs as lang}
function create_each_block(ctx) {
	let current;

	const underlinelink = new UnderlineLink({
			props: {
				href: indexUrl({ lang: /*lang*/ ctx[4].code }),
				text: /*lang*/ ctx[4].native,
				desc: /*lang*/ ctx[4].en
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(underlinelink.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(underlinelink.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(underlinelink, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(underlinelink.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(underlinelink.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(underlinelink, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(31:4) {#each langs as lang}",
		ctx
	});

	return block;
}

// (30:2) <LinkListBox>
function create_default_slot_1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*langs*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*indexUrl, langs*/ 8) {
				each_value = /*langs*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(30:2) <LinkListBox>",
		ctx
	});

	return block;
}

// (28:0) <Page {meta}>
function create_default_slot(ctx) {
	let h1;
	let t0_value = /*$trans*/ ctx[1]("langs.title") + "";
	let t0;
	let t1;
	let current;

	const linklistbox = new LinkListBox({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			create_component(linklistbox.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, t0_value);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(linklistbox.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 28, 2, 709);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(linklistbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*$trans*/ 2) && t0_value !== (t0_value = /*$trans*/ ctx[1]("langs.title") + "")) set_data_dev(t0, t0_value);
			const linklistbox_changes = {};

			if (dirty & /*$$scope*/ 512) {
				linklistbox_changes.$$scope = { dirty, ctx };
			}

			linklistbox.$set(linklistbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(linklistbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(linklistbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(linklistbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(28:0) <Page {meta}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current;

	const page_1 = new Page({
			props: {
				meta: /*meta*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(page_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(page_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_1_changes = {};
			if (dirty & /*meta*/ 1) page_1_changes.meta = /*meta*/ ctx[0];

			if (dirty & /*$$scope, $trans*/ 514) {
				page_1_changes.$$scope = { dirty, ctx };
			}

			page_1.$set(page_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $trans;
	let $lang;
	const { page } = stores$1();
	const { lang, trans } = stores();
	validate_store(lang, "lang");
	component_subscribe($$self, lang, value => $$invalidate(5, $lang = value));
	validate_store(trans, "trans");
	component_subscribe($$self, trans, value => $$invalidate(1, $trans = value));

	const langs = Object.values(map).sort((a, b) => {
		a.native.localeCompare(b.native);
	});

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("meta" in $$props) $$invalidate(0, meta = $$props.meta);
		if ("$trans" in $$props) trans.set($trans = $$props.$trans);
		if ("$lang" in $$props) lang.set($lang = $$props.$lang);
	};

	let meta;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$trans, $lang*/ 34) {
			 $$invalidate(0, meta = {
				title: $trans("langs.head.title"),
				desc: $trans("langs.head.desc"),
				canonical: canonical(langsUrl({ lang: $lang }))
			});
		}
	};

	return [meta, $trans, trans, langs, lang];
}

class Languages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Languages",
			options,
			id: create_fragment.name
		});
	}
}

export default Languages;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFuZ3VhZ2VzLjNhZTg5OThkLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL1tsYW5nKFthLXpdezJ9KV0vbGFuZ3VhZ2VzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgUGFnZSBmcm9tIFwiL0NvbXBvbmVudHMvUGFnZS5zdmVsdGVcIjtcbiAgaW1wb3J0IFVuZGVybGluZUxpbmsgZnJvbSBcIi9Db21wb25lbnRzL1VuZGVybGluZUxpbmsuc3ZlbHRlXCI7XG4gIGltcG9ydCBMaW5rTGlzdEJveCBmcm9tIFwiL0NvbXBvbmVudHMvTGlua0xpc3RCb3guc3ZlbHRlXCI7XG5cbiAgaW1wb3J0IHsgc3RvcmVzIH0gZnJvbSBcIkBzYXBwZXIvYXBwXCI7XG4gIGNvbnN0IHsgcGFnZSB9ID0gc3RvcmVzKCk7XG5cbiAgaW1wb3J0ICogYXMgaTE4biBmcm9tIFwiL0NvbW1vbi9pMThuXCI7XG4gIGNvbnN0IHsgbGFuZywgdHJhbnMgfSA9IGkxOG4uc3RvcmVzKCk7XG5cbiAgaW1wb3J0IHsgY2Fub25pY2FsLCBsYW5nc1VybCwgaW5kZXhVcmwgfSBmcm9tIFwiL0NvbW1vbi91cmxzXCI7XG5cbiAgaW1wb3J0IG1hcCBmcm9tIFwiL2RiL2RhdGEvbGFuZ3MuanNvblwiO1xuXG4gIGNvbnN0IGxhbmdzID0gT2JqZWN0LnZhbHVlcyhtYXApLnNvcnQoKGEsIGIpID0+IHtcbiAgICBhLm5hdGl2ZS5sb2NhbGVDb21wYXJlKGIubmF0aXZlKTtcbiAgfSk7XG5cbiAgJDogbWV0YSA9IHtcbiAgICB0aXRsZTogJHRyYW5zKFwibGFuZ3MuaGVhZC50aXRsZVwiKSxcbiAgICBkZXNjOiAkdHJhbnMoXCJsYW5ncy5oZWFkLmRlc2NcIiksXG4gICAgY2Fub25pY2FsOiBjYW5vbmljYWwobGFuZ3NVcmwoe2xhbmc6ICRsYW5nfSkpXG4gIH07XG5cbjwvc2NyaXB0PlxuXG48UGFnZSB7bWV0YX0+XG4gIDxoMT57JHRyYW5zKCdsYW5ncy50aXRsZScpfTwvaDE+XG4gIDxMaW5rTGlzdEJveD5cbiAgICB7I2VhY2ggbGFuZ3MgYXMgbGFuZ31cbiAgICAgIDxVbmRlcmxpbmVMaW5rXG4gICAgICAgIGhyZWY9e2luZGV4VXJsKHsgbGFuZzogbGFuZy5jb2RlIH0pfVxuICAgICAgICB0ZXh0PXtsYW5nLm5hdGl2ZX1cbiAgICAgICAgZGVzYz17bGFuZy5lbn0gLz5cbiAgICB7L2VhY2h9XG4gIDwvTGlua0xpc3RCb3g+XG48L1BhZ2U+XG4iXSwibmFtZXMiOlsic3RvcmVzIiwiaTE4bi5zdG9yZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFnQ2MsUUFBUSxHQUFHLElBQUksV0FBRSxHQUFJLElBQUMsSUFBSTttQkFDMUIsR0FBSSxJQUFDLE1BQU07bUJBQ1gsR0FBSSxJQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBSlYsR0FBSzs7O2dDQUFWLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFBQyxHQUFLOzs7K0JBQVYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFBSixNQUFJOzs7Ozs7Ozs7O2tDQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQUZILEdBQU0sSUFBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRkFBcEIsR0FBTSxJQUFDLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0F0QmpCLElBQUksS0FBS0EsUUFBTTtTQUdmLElBQUksRUFBRSxLQUFLLEtBQUtDLE1BQVc7Ozs7OztPQU03QixLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDO0VBQ3pDLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7OztvQkFHOUIsSUFBSTtJQUNMLEtBQUssRUFBRSxNQUFNLENBQUMsa0JBQWtCO0lBQ2hDLElBQUksRUFBRSxNQUFNLENBQUMsaUJBQWlCO0lBQzlCLFNBQVMsRUFBRSxTQUFTLENBQUMsUUFBUSxHQUFFLElBQUksRUFBRSxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
