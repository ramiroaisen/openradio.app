import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as stores$1, z as validate_store, A as component_subscribe, y as stores, B as canonical, ab as signalListUrl, C as create_component, D as claim_component, E as mount_component, p as transition_in, v as transition_out, F as destroy_component, e as element, H as text, a as space, b as claim_element, h as children, I as claim_text, f as detach_dev, g as claim_space, k as add_location, m as insert_dev, l as append_dev, J as set_data_dev, ac as signalUrl, T as empty, K as group_outros, L as check_outros, M as destroy_each } from './client.c54ac804.js';
import { P as Page } from './Page.8d242014.js';
import { L as LinkListBox, U as UnderlineLink } from './LinkListBox.4c078f97.js';

/* src/routes/_shared/signalList.svelte generated by Svelte v3.18.2 */
const file = "src/routes/_shared/signalList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (53:4) {#each signals as frec}
function create_each_block(ctx) {
	let t;
	let current;

	const underlinelink = new UnderlineLink({
			props: {
				href: signalUrl({
					lang: /*$lang*/ ctx[6],
					countryCode: /*$countryCode*/ ctx[3],
					type: /*type*/ ctx[1],
					frec: /*frec*/ ctx[12]
				}),
				text: /*$trans*/ ctx[4]("signal.link.text", {
					type: /*type*/ ctx[1],
					frec: /*frec*/ ctx[12]
				})
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(underlinelink.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(underlinelink.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(underlinelink, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const underlinelink_changes = {};

			if (dirty & /*$lang, $countryCode, type, signals*/ 75) underlinelink_changes.href = signalUrl({
				lang: /*$lang*/ ctx[6],
				countryCode: /*$countryCode*/ ctx[3],
				type: /*type*/ ctx[1],
				frec: /*frec*/ ctx[12]
			});

			if (dirty & /*$trans, type, signals*/ 19) underlinelink_changes.text = /*$trans*/ ctx[4]("signal.link.text", {
				type: /*type*/ ctx[1],
				frec: /*frec*/ ctx[12]
			});

			underlinelink.$set(underlinelink_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(underlinelink.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(underlinelink.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(underlinelink, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(53:4) {#each signals as frec}",
		ctx
	});

	return block;
}

// (52:2) <LinkListBox>
function create_default_slot_1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*signals*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*signalUrl, $lang, $countryCode, type, signals, $trans*/ 91) {
				each_value = /*signals*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(52:2) <LinkListBox>",
		ctx
	});

	return block;
}

// (50:0) <Page {meta}>
function create_default_slot(ctx) {
	let h1;
	let t0;
	let t1;
	let current;

	const linklistbox = new LinkListBox({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text(/*title*/ ctx[2]);
			t1 = space();
			create_component(linklistbox.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[2]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(linklistbox.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 50, 2, 1612);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(linklistbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*title*/ 4) set_data_dev(t0, /*title*/ ctx[2]);
			const linklistbox_changes = {};

			if (dirty & /*$$scope, signals, $lang, $countryCode, type, $trans*/ 32859) {
				linklistbox_changes.$$scope = { dirty, ctx };
			}

			linklistbox.$set(linklistbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(linklistbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(linklistbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(linklistbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(50:0) <Page {meta}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current;

	const page_1 = new Page({
			props: {
				meta: /*meta*/ ctx[5],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(page_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(page_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(page_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const page_1_changes = {};
			if (dirty & /*meta*/ 32) page_1_changes.meta = /*meta*/ ctx[5];

			if (dirty & /*$$scope, signals, $lang, $countryCode, type, $trans, title*/ 32863) {
				page_1_changes.$$scope = { dirty, ctx };
			}

			page_1.$set(page_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(page_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(page_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(page_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload($page, $session) {
	let url = `/api/signal/${$page.params.signalType}`;

	if ($page.params.langCountry) {
		const [_, $countryCode] = $page.params.langCountry.split("-");
		url += `?countryCode=${$countryCode}`;
	}

	const signals = await this.fetch(url).then(res => res.json());
	return { signals };
}

function instance($$self, $$props, $$invalidate) {
	let $page;
	let $countryCode;
	let $trans;
	let $lang;
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(11, $page = value));
	const { trans, lang, countryCode } = stores();
	validate_store(trans, "trans");
	component_subscribe($$self, trans, value => $$invalidate(4, $trans = value));
	validate_store(lang, "lang");
	component_subscribe($$self, lang, value => $$invalidate(6, $lang = value));
	validate_store(countryCode, "countryCode");
	component_subscribe($$self, countryCode, value => $$invalidate(3, $countryCode = value));
	let { signals } = $$props;
	const writable_props = ["signals"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SignalList> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("signals" in $$props) $$invalidate(0, signals = $$props.signals);
	};

	$$self.$capture_state = () => {
		return {
			signals,
			type,
			$page,
			title,
			$countryCode,
			$trans,
			meta,
			$lang
		};
	};

	$$self.$inject_state = $$props => {
		if ("signals" in $$props) $$invalidate(0, signals = $$props.signals);
		if ("type" in $$props) $$invalidate(1, type = $$props.type);
		if ("$page" in $$props) page.set($page = $$props.$page);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("$countryCode" in $$props) countryCode.set($countryCode = $$props.$countryCode);
		if ("$trans" in $$props) trans.set($trans = $$props.$trans);
		if ("meta" in $$props) $$invalidate(5, meta = $$props.meta);
		if ("$lang" in $$props) lang.set($lang = $$props.$lang);
	};

	let type;
	let title;
	let meta;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$page*/ 2048) {
			 $$invalidate(1, type = $page.params.signalType);
		}

		if ($$self.$$.dirty & /*$countryCode, $trans, type*/ 26) {
			 $$invalidate(2, title = $countryCode
			? $trans("signalList.country.title", {
					type,
					country: $trans(`countries.${$countryCode}`)
				})
			: $trans("signalList.global.title", { type }));
		}

		if ($$self.$$.dirty & /*$countryCode, $trans, type, $lang*/ 90) {
			 $$invalidate(5, meta = $countryCode
			? {
					title: $trans("signalList.head.country.title", {
						type,
						country: $trans(`countries.${$countryCode}`)
					}),
					desc: $trans("signalList.head.country.desc", {
						type,
						country: $trans(`countries.${$countryCode}`)
					}),
					canonical: canonical(signalListUrl({
						lang: $lang,
						countryCode: $countryCode,
						type
					}))
				}
			: {
					title: $trans("signalList.head.global.title", { type }),
					desc: $trans("signalList.head.global.title", { type }),
					canonical: canonical(signalListUrl({ lang: $lang, type }))
				});
		}
	};

	return [
		signals,
		type,
		title,
		$countryCode,
		$trans,
		meta,
		$lang,
		page,
		trans,
		lang,
		countryCode
	];
}

class SignalList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { signals: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SignalList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*signals*/ ctx[0] === undefined && !("signals" in props)) {
			console.warn("<SignalList> was created without expected prop 'signals'");
		}
	}

	get signals() {
		throw new Error("<SignalList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set signals(value) {
		throw new Error("<SignalList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { SignalList as C, preload as p };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsTGlzdC5lZjQ2OGQwMy5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9fc2hhcmVkL3NpZ25hbExpc3Quc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCgkcGFnZSwgJHNlc3Npb24pe1xuICAgIGxldCB1cmwgPSBgL2FwaS9zaWduYWwvJHskcGFnZS5wYXJhbXMuc2lnbmFsVHlwZX1gO1xuICAgIGlmKCRwYWdlLnBhcmFtcy5sYW5nQ291bnRyeSl7XG4gICAgICBjb25zdCBbXywgJGNvdW50cnlDb2RlXSA9ICRwYWdlLnBhcmFtcy5sYW5nQ291bnRyeS5zcGxpdChcIi1cIik7XG4gICAgICB1cmwgKz0gYD9jb3VudHJ5Q29kZT0keyRjb3VudHJ5Q29kZX1gO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25hbHMgPSBhd2FpdCB0aGlzLmZldGNoKHVybCkudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG5cbiAgICByZXR1cm4ge3NpZ25hbHN9O1xuICB9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IFBhZ2UgZnJvbSBcIi9Db21wb25lbnRzL1BhZ2Uuc3ZlbHRlXCI7XG4gIGltcG9ydCBVbmRlcmxpbmVMaW5rIGZyb20gXCIvQ29tcG9uZW50cy9VbmRlcmxpbmVMaW5rLnN2ZWx0ZVwiO1xuICBpbXBvcnQgTGlua0xpc3RCb3ggZnJvbSBcIi9Db21wb25lbnRzL0xpbmtMaXN0Qm94LnN2ZWx0ZVwiO1xuXG4gIGltcG9ydCB7c2lnbmFsVXJsfSBmcm9tIFwiL0NvbW1vbi91cmxzXCI7XG5cbiAgaW1wb3J0IHtzdG9yZXN9IGZyb20gXCJAc2FwcGVyL2FwcFwiO1xuICBjb25zdCB7cGFnZX0gPSBzdG9yZXMoKTtcblxuICBpbXBvcnQgKiBhcyBpMThuIGZyb20gXCIvQ29tbW9uL2kxOG5cIjtcbiAgY29uc3Qge3RyYW5zLCBsYW5nLCBjb3VudHJ5Q29kZX0gPSBpMThuLnN0b3JlcygpO1xuXG4gICQ6IHR5cGUgPSAkcGFnZS5wYXJhbXMuc2lnbmFsVHlwZTtcblxuICAkOiB0aXRsZSA9ICRjb3VudHJ5Q29kZSA/IFxuICAgICR0cmFucyhcInNpZ25hbExpc3QuY291bnRyeS50aXRsZVwiLCB7dHlwZSwgY291bnRyeTogJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCl9KSA6XG4gICAgJHRyYW5zKFwic2lnbmFsTGlzdC5nbG9iYWwudGl0bGVcIiwge3R5cGV9KTtcblxuICBleHBvcnQgbGV0IHNpZ25hbHM7XG5cbiAgaW1wb3J0IHtjYW5vbmljYWwsIHNpZ25hbExpc3RVcmx9IGZyb20gXCIvQ29tbW9uL3VybHNcIjtcblxuICAkOiBtZXRhID0gICRjb3VudHJ5Q29kZSA/IHtcbiAgICB0aXRsZTogJHRyYW5zKFwic2lnbmFsTGlzdC5oZWFkLmNvdW50cnkudGl0bGVcIiwge3R5cGUsIGNvdW50cnk6ICR0cmFucyhgY291bnRyaWVzLiR7JGNvdW50cnlDb2RlfWApfSksXG4gICAgZGVzYzogJHRyYW5zKFwic2lnbmFsTGlzdC5oZWFkLmNvdW50cnkuZGVzY1wiLCB7dHlwZSwgY291bnRyeTogJHRyYW5zKGBjb3VudHJpZXMuJHskY291bnRyeUNvZGV9YCl9KSxcbiAgICBjYW5vbmljYWw6IGNhbm9uaWNhbChzaWduYWxMaXN0VXJsKHtsYW5nOiAkbGFuZywgY291bnRyeUNvZGU6ICRjb3VudHJ5Q29kZSwgdHlwZX0pKVxuICB9IDoge1xuICAgIHRpdGxlOiAkdHJhbnMoXCJzaWduYWxMaXN0LmhlYWQuZ2xvYmFsLnRpdGxlXCIsIHt0eXBlfSksXG4gICAgZGVzYzogJHRyYW5zKFwic2lnbmFsTGlzdC5oZWFkLmdsb2JhbC50aXRsZVwiLCB7dHlwZX0pLFxuICAgIGNhbm9uaWNhbDogY2Fub25pY2FsKHNpZ25hbExpc3RVcmwoe2xhbmc6ICRsYW5nLCB0eXBlfSkpXG4gIH07XG5cbjwvc2NyaXB0PlxuXG48UGFnZSB7bWV0YX0+XG4gIDxoMT57dGl0bGV9PC9oMT5cbiAgPExpbmtMaXN0Qm94PlxuICAgIHsjZWFjaCBzaWduYWxzIGFzIGZyZWN9XG4gICAgICA8VW5kZXJsaW5lTGluayBcbiAgICAgICAgaHJlZj17c2lnbmFsVXJsKHtsYW5nOiAkbGFuZywgY291bnRyeUNvZGU6ICRjb3VudHJ5Q29kZSwgdHlwZSwgZnJlY30pfVxuICAgICAgICB0ZXh0PXskdHJhbnMoXCJzaWduYWwubGluay50ZXh0XCIsIHt0eXBlLCBmcmVjfSl9XG4gICAgICAvPlxuICAgICAgPCEtLSAgZGVzYz17JHRyYW5zKFwicmFkaW9Db3VudFwiLCB7Y291bnR9KX0gLS0+XG4gICAgey9lYWNofVxuICA8L0xpbmtMaXN0Qm94PlxuPC9QYWdlPiJdLCJuYW1lcyI6WyJzdG9yZXMiLCJpMThuLnN0b3JlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFzRGMsU0FBUztLQUFFLElBQUksWUFBRSxHQUFLO0tBQUUsV0FBVyxtQkFBRSxHQUFZO0tBQUUsSUFBSSxXQUFKLEdBQUk7S0FBRSxJQUFJLFdBQUosR0FBSTs7cUJBQzdELEdBQU0sSUFBQyxrQkFBa0I7S0FBRyxJQUFJLFdBQUosR0FBSTtLQUFFLElBQUksV0FBSixHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RkFEdEMsU0FBUztJQUFFLElBQUksWUFBRSxHQUFLO0lBQUUsV0FBVyxtQkFBRSxHQUFZO0lBQUUsSUFBSSxXQUFKLEdBQUk7SUFBRSxJQUFJLFdBQUosR0FBSTs7O3FGQUM3RCxHQUFNLElBQUMsa0JBQWtCO0lBQUcsSUFBSSxXQUFKLEdBQUk7SUFBRSxJQUFJLFdBQUosR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBSHpDLEdBQU87OztnQ0FBWixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBQUMsR0FBTzs7OytCQUFaLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBQUosTUFBSTs7Ozs7Ozs7OztrQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFGSCxHQUFLOzs7Ozs7Ozt1Q0FBTCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7OzttRUFBTCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBakRZLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUTtLQUN2QyxHQUFHLGtCQUFrQixLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVU7O0tBQzdDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVztTQUNsQixDQUFDLEVBQUUsWUFBWSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHO0VBQzVELEdBQUcsb0JBQW9CLFlBQVk7OztPQUcvQixPQUFPLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSTtVQUVsRCxPQUFPOzs7Ozs7OztTQUZWLElBQUksS0FBSUEsUUFBTTs7O1NBR2QsS0FBSyxFQUFFLElBQUksRUFBRSxXQUFXLEtBQUlDLE1BQVc7Ozs7Ozs7T0FRbkMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTmYsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVTs7OztvQkFFOUIsS0FBSyxHQUFHLFlBQVk7S0FDckIsTUFBTSxDQUFDLDBCQUEwQjtLQUFHLElBQUk7S0FBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLFlBQVk7O0tBQ25GLE1BQU0sQ0FBQyx5QkFBeUIsSUFBRyxJQUFJOzs7O29CQU10QyxJQUFJLEdBQUksWUFBWTs7S0FDckIsS0FBSyxFQUFFLE1BQU0sQ0FBQywrQkFBK0I7TUFBRyxJQUFJO01BQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxZQUFZOztLQUMvRixJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QjtNQUFHLElBQUk7TUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLFlBQVk7O0tBQzdGLFNBQVMsRUFBRSxTQUFTLENBQUMsYUFBYTtNQUFFLElBQUksRUFBRSxLQUFLO01BQUUsV0FBVyxFQUFFLFlBQVk7TUFBRSxJQUFJOzs7O0tBRWhGLEtBQUssRUFBRSxNQUFNLENBQUMsOEJBQThCLElBQUcsSUFBSTtLQUNuRCxJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QixJQUFHLElBQUk7S0FDbEQsU0FBUyxFQUFFLFNBQVMsQ0FBQyxhQUFhLEdBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
